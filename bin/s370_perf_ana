#!/usr/bin/perl -w
# $Id: s370_perf_ana 1000 2018-03-17 16:56:47Z mueller $
#
# Copyright 2017-2018 by Walter F.J. Mueller <W.F.J.Mueller@gsi.de>
#
# This program is free software; you may redistribute and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3, or at your option any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for complete details.
#
#  Revision History:
# Date         Rev Version  Comment
# 2018-03-17  1000   1.4    cleanup ^L handling; add -dt,-dl,-du,-nonrr
# 2018-03-10   999   1.3.1  add -w2,-csv options; change -lrun to -nolrun
# 2018-03-03   996   1.3    print s370_perf version; add -raw,-t311,-t312
# 2018-02-24   994   1.2.1  add -d3 for fast systems
# 2018-01-28   991   1.2    add chktag; add -cf,-cp,-cn
# 2018-01-06   986   1.1.2  rename to s370_perf_ana
# 2017-12-16   970   1.1.1  add sprt() for sliding precision in output
# 2017-12-10   969   1.1    adopt to new file format; add loop timing correction
# 2017-11-16   962   1.0    Initial version
# 2017-10-15   956   0.1    First draft
#

use 5.14.0;                                 # require Perl 5.14 or higher
use strict;                                 # require strict checking
use Getopt::Long;

my %opts = ();
my %tags;
my $s370_perf_vers;

GetOptions(\%opts, 'help', 'ltpi', 'ldf',
           'raw', 'csv', 'nolrun', 'nolcor', 'nonrr', 'ttim',
           'dt=f','dl=f','du=f',
           'd1', 'd3','w2','w3',
           't311=f','t312=f',
           'cf=f', 'cp=f', 'cn=i')
  or die "bad options";

my $csv = $opts{csv};
my $dolcor = not exists $opts{nolcor};

# handle help
if (defined $opts{help}) { do_help();  exit 0; }

# handle -cf, map to -cp
$opts{cp} = 1000./$opts{cf} if exists $opts{cf};

# handle -dt, -dl, -du
if ((exists $opts{dt} && ($opts{dt} < 0. || $opts{dt} > 1.)) ||
    (exists $opts{dl} && ($opts{dl} < 0. || $opts{dl} > 1.)) ||
    (exists $opts{du} && ($opts{du} < 0. || $opts{du} > 1.))) {
  print "s370_perf_ana-E bad value, -dt,dl and -du must be in [0.,1.] \n";
  exit 1;
}
my $dt = 0.50;
my $dl = 0.25;
my $du = 0.75;
if (exists $opts{dt}) {
  $dt = $opts{dt};
  $dl = $dt - 0.25;
  $du = $dt + 0.25;
  if ($dl < 0.) {$dl = 0.0; $du = 0.5;}
  if ($du > 1.) {$dl = 0.5; $du = 1.0;}
}
$dl = $opts{dl} if exists  $opts{dl};
$du = $opts{du} if exists  $opts{du};
if ($du <= $dl) {
  print "s370_perf_ana-E bad values, -du must be larger than -dl\n";
  exit 1;
}

#
# print essential options
#
my $opttxt;
$opttxt .= '  -raw'                 if exists $opts{raw};
$opttxt .= '  -nolcor'              if exists $opts{nolcor};
$opttxt .= '  -nonrr'               if exists $opts{nonrr};
$opttxt .= '  -ttim'                if exists $opts{ttim};
$opttxt .= '  -dt '   . $opts{dt}   if exists $opts{dt};
$opttxt .= '  -dl '   . $opts{dl}   if exists $opts{dl};
$opttxt .= '  -du '   . $opts{du}   if exists $opts{du};
$opttxt .= '  -cf '   . $opts{cf}   if exists $opts{cf};
$opttxt .= '  -cp '   . sprintf '%6.3f',$opts{cp} if exists $opts{cp};
$opttxt .= '  -cn '   . $opts{cn}   if exists $opts{cn};
$opttxt .= '  -t311 ' . $opts{t311} if exists $opts{t311};
$opttxt .= '  -t312 ' . $opts{t312} if exists $opts{t312};
printf "s370_perf_ana%s\n\n",$opttxt if defined $opttxt && not $csv;
#
# handle input files
#

print "file name ----------------------------".
      "  GMUL  i-count  -- total time --   MIPS\n" unless $opts{nolrun} || $csv;

foreach my $fname (@ARGV) {
  do_file($fname);
}

unless ($csv) {
  print "s370_perf version: $s370_perf_vers\n" if defined $s370_perf_vers;
  print "\n" unless $opts{nolrun};
}

do_anal();
do_show();

exit 0;

#
# -- do_help: print help text ------------------------------------------------
#

sub do_help {
  print "usage: s370_perf_ana [OPTIONS] [FILE]...\n";
  print "  -d1      decrease time field precision (for slow systems)\n";
  print "  -d3      increase time field precision (for fast systems)\n";
  print "  -w2      increase w50 field precision\n";
  print "  -w3      increase w50 field precision\n";
  print "  -nolcor  no loop (bctr/bct) timing correction\n";
  print "  -nonrr   fill n-rr and n-rx with 0.0 dummy data\n";
  print "  -dt=f    cdf lookup value for tpi extraction (default 0.5)\n";
  print "  -dl=f    cdf lookup value lower end of w50 interval\n";
  print "  -du=f    cdf lookup value upper end of w50 interval\n";
  print "  -t311=t  override time used for bctr loop correction\n";
  print "  -t312=t  override time used for bct  loop correction\n";
  print "  -nolrun  suppress file/run statistics\n";
  print "  -ltpi    list per run tpi values\n";
  print "  -ldf     list tpi distribution function\n";
  print "  -raw     show raw data\n";
  print "  -csv     output in csv format for spreadsheet import\n";
  print "  -cp=p    specify clock period (in ns)\n";
  print "  -cf=f    specify clock frequency (in MHz)\n";
  print "  -cn=n    number of clock phases (default = 1)\n";
  print "  -ttim    use test time field (instead of instruction time)\n";
  print "  -help    help text\n";
  return;
}

#
# -- do_file: handle input file ----------------------------------------------
#

sub do_file {
  my ($fname) = @_;
  open IFILE,"<$fname" or die "failed to open $fname";

  my $resok = 0;
  my $gmul  = 0;
  my $gtim  = 0;
  my $gcnt  = 0;
  my $vers;

  while (<IFILE>) {
    chomp;
    s{\r}{}g;                               # drop ^M
    my @lines = split /\f/,$_;              # split on lone ^L
    foreach (@lines) {
      $gmul  = $1 if m/^PERF002I run with GMUL=\s*(\d+)/;
      if (m/^PERF003I start with tests/) {
        $resok = 1;
        $gtim  = 0.;
        $gcnt  = 0;
      }
      if (m/^PERF000I VERS:\s*(.*)$/) {
        if (defined $s370_perf_vers && $s370_perf_vers ne $1) {
          print "s370_perf_ana-W mixed s370_perf version: $1\n";
        }
        $s370_perf_vers = $1;
      }
      next unless $resok;

      if (m/^(T\d\d\d)\s+                     # tag
            ([^:]*?)\s+:\s+                   # txt
            (\d+\.\d+)\s+                     # test time
            (\d+)\s+                          # lrcnt
            (\d+)\s+                          # igcnt
            (\d+)\s+:\s+                      # ltype
            (\d+\.\d+)\s*$/x) {               # tpi
        my $tag   = $1;
        my $txt   = $2;
        my $tim   = $3;
        my $lrcnt = $4;
        my $igcnt = $5;
        my $ltype = $6;
        my $tpi   = $7;
        ##printf "%s %-28s %6.2f %8d %6.4f\n",
        ##       $tag,$txt,$tim,$lrcnt,$igcnt,$ltype,$tpi;
        if (not exists $tags{$tag}) {
          $tags{$tag}{txt} = $txt;
        } else {
          if ($tags{$tag}{txt} ne $txt) {
            $tags{$tag}{txt} = $txt;
            print "s370_perf_ana-W tag text for $tag redefined\n";
          }
        }
        my $lcnt = 1. * $gmul * $lrcnt * $igcnt;
        $tpi = 1.e6 * $tim / $lcnt if ($opts{ttim});
        $gcnt += $lcnt;
        $gtim += $lcnt * $tpi * 1.e-6;
        push @{$tags{$tag}{tpival}},(1000.*$tpi);
        $tags{$tag}{lrcnt} = $lrcnt;
        $tags{$tag}{igcnt} = $igcnt;
        $tags{$tag}{ltype} = $ltype;
      } else {
        print "s370_perf_ana-W failed to parse apparent test line\n'$_'\n"
          if m/^(T\d\d\d)\s+/;
      }

      if (m/^PERF004I done with tests/) {
        $resok = 0;
        unless ($opts{nolrun} || $csv) {
          my $gtim_min = int ($gtim/60.);
          my $gtim_sec = $gtim - 60.*$gtim_min;
          my $mips = ($gtim>0) ? 1.e-6*$gcnt/$gtim : 0.;
          printf "%-38s %5d %8.2e  %6.2fs %2dm%05.2f %6.1f\n",
            substr($fname,-38),$gmul,$gcnt,$gtim,$gtim_min,$gtim_sec,$mips;
        }
      }
    }
  }

  close IFILE;
  return;
}

#
# -- do_anal: do analysis ----------------------------------------------------
#

sub do_anal {
  foreach my $tag (sort keys %tags) {
    my @tpisort = sort { $a <=> $b } @{$tags{$tag}{tpival}};
    ## printf "%s : %s\n",$tag,join(",", @tpisort);
    my $tpicnt = scalar(@tpisort);
    my $tpimin = $tpisort[0];
    my $tpimax = $tpisort[-1];
    my $dfl = df_lookup(\@tpisort, $dl);
    my $dft = df_lookup(\@tpisort, $dt);
    my $dfu = df_lookup(\@tpisort, $du);
    $tags{$tag}{tpicnt} = $tpicnt;
    $tags{$tag}{tpimin} = $tpimin;
    $tags{$tag}{tpimax} = $tpimax;
    $tags{$tag}{tpimed} = $dft;
    $tags{$tag}{tpiw50} = $dfu-$dfl;
    $tags{$tag}{tpicor} = $dft;
  }

  return unless $dolcor;

  my @lcor = (0.,0.,0.);
  unless ($opts{t311}) {
    return if chktag('T311','BCTR');
    $lcor[1] = $tags{T311}{tpimed};
  } else {
    $lcor[1] = $opts{t311};
  }
  unless ($opts{t312}) {
    return if chktag('T312','BCT');
    $lcor[2] = $tags{T312}{tpimed};
  } else {
    $lcor[2] = $opts{t312};
  }

  foreach my $tag (sort keys %tags) {
    my $tpimed = $tags{$tag}{tpimed};
    my $ltype  = $tags{$tag}{ltype};
    if ($ltype >= 0 && $ltype <= 2) {
      $tags{$tag}{tpicor} = $tpimed - $lcor[$ltype] / $tags{$tag}{igcnt};
    }
  }
  return;
}

#
# -- df_lookup: lookup df ----------------------------------------------------
#
sub df_lookup {
  my ($df,$frac) = @_;
  my $nval = scalar(@{$df});
  return 0.        if $nval == 0;
  return $df->[0]  if $nval == 1;
  my $imax = $nval - 1;
  my $rind = $frac * $imax;
  my $ind  = int $rind;
  return $df->[$ind] if $ind == $imax;
  my $find = $rind - $ind;
  return (1.-$find)*$df->[$ind] + $find*$df->[$ind+1];
}

#
# -- do_show: show analysis---------------------------------------------------
#

sub do_show {
  return if chktag('T100','LR');
  return if chktag('T102','L');
  my $norrr = $tags{T100}{tpicor};
  my $norrx = $tags{T102}{tpicor};

  my $del  = $csv ? '|' : ' ';
  my $edel = $csv ? '|' : ':';
  my $psym = $csv ? '%' : '%';

  #
  # print heading line
  #
  printf 'Tag ';
  printf '%s Comment                ',$del;
  printf '%s nt',$edel;
  unless ($opts{raw}) {
    printf '%s    min', $del;
    printf '%s    max', $del;
    printf '%s     tpi', $del;
    printf '%s  w50%s', $del,$psym;
    printf '%s   n-rr', $del;
    printf '%s  n-rx',  $del;
  } else {
    printf '%s     lr',    $del;
    printf '%s ig',        $del;
    printf '%slt',         $del;
    printf '%s       raw', $del;
    printf '%s  w50%s',    $del,$psym;
  }
  if ($opts{cp}) {
    printf '%s   n-cp', $del;
    printf '%s e-cp%s', $del,$psym;
    printf '%s  mcc',   $del;;
  }
  printf '%s  scc',$del if $opts{cn};
  printf "\n";

  #
  # setup formats
  #
  my $fmt1 = '%7.1f';
  my $fmt2 = '%8.2f';
  my $fmt3 = '%10.2f';
  if ($opts{d1}) {
    $fmt1 = '%7.0f';
    $fmt2 = '%8.1f';
    $fmt3 = '%10.1f';
  }
  if ($opts{d3}) {
    $fmt1 = '%7.2f';
    $fmt2 = '%8.3f';
    $fmt3 = '%10.3f';
  }
  my $fmtw1 = '%5.1f';
  if ($opts{w2}) {
    $fmtw1 = '%5.2f';
  }
  if ($opts{w3}) {
    $fmtw1 = '%5.3f';
  }

  #
  # print test lines
  #
  foreach my $tag (sort keys %tags) {
    my $w50pcent = 100.*$tags{$tag}{tpiw50}/$tags{$tag}{tpimed};
    my $nrr = (defined $opts{nonrr}) ? 0.0 : $tags{$tag}{tpicor}/$norrr;
    my $nrx = (defined $opts{nonrr}) ? 0.0 : $tags{$tag}{tpicor}/$norrx;

    printf '%s',        $tag;
    printf '%s %-22s ', $del, $tags{$tag}{txt};
    printf '%s%3d',     $edel, $tags{$tag}{tpicnt};

    unless ($opts{raw}) {
      printf '%s%s',   $del,sprt($tags{$tag}{tpimin},$fmt1);
      printf '%s%s',   $del,sprt($tags{$tag}{tpimax},$fmt1);
      printf '%s%s',   $del,sprt($tags{$tag}{tpicor},$fmt2);
      printf '%s%s%s', $del,sprt($w50pcent,$fmtw1), $psym;
      printf '%s%s',   $del,sprt($nrr,'%7.2f');
      printf '%s%s',   $del,sprt($nrx,'%6.2f');
    } else {
      my $totraw = $tags{$tag}{igcnt}*$tags{$tag}{tpimed};
      printf '%s%7d',  $del,$tags{$tag}{lrcnt};
      printf '%s%3d',  $del,$tags{$tag}{igcnt};
      printf '%s%2d',  $del,$tags{$tag}{ltype};
      printf '%s%s',   $del,sprt($totraw,$fmt3);
      printf '%s%s%s', $del,sprt($w50pcent,$fmtw1), $psym;
    }
    if (exists $opts{cp}) {
      my $time = $opts{raw} ?
                   $tags{$tag}{igcnt}*$tags{$tag}{tpimed} :
                   $tags{$tag}{tpicor};
      my $ncp = $time / $opts{cp};
      my $cc  = int($ncp + 0.5);
      my $ecp = 100. * ($ncp - $cc);
      printf '%s%s',    $del,sprt($ncp,'%7.2f');
      printf '%s%5d%s', $del,$ecp,$psym;
      if (exists $opts{cn}) {
        my $mcc = int($cc/$opts{cn});
        my $scc = $cc - $mcc * $opts{cn};
        printf '%s%5d',$del,$mcc;
        printf '%s%5d',$del,$scc;
      } else {
        printf '%s%5d',$del,$cc;
      }
    }
    print "\n";

    if ($opts{ltpi} && not $csv) {
      my $ival = 0;
      my $nval = scalar(@{$tags{$tag}{tpival}});
      foreach my $val (@{$tags{$tag}{tpival}}) {
        print  '  tpi:' if $ival%5 == 0;
        printf '  %8.3f',$val;
        $ival += 1;
        print "\n" if $ival%5 == 0;
      }
      print "\n" unless $ival%5 == 0;
    }
    if ($opts{ldf} && not $csv) {
      my @tpisort = sort { $a <=> $b } @{$tags{$tag}{tpival}};
      my $ival = 0;
      my $nval = scalar(@tpisort);
      foreach my $val (@tpisort) {
        print  '  cdf:' if $ival%5 == 0;
        printf '  %8.3f',$val;
        $ival += 1;
        print "\n" if $ival%5 == 0;
      }
      print "\n" unless $ival%5 == 0;

      printf "  %4.2f: %8.3f\n", $dl,df_lookup(\@tpisort, $dl);
      printf "  %4.2f: %8.3f\n", $dt,df_lookup(\@tpisort, $dt);
      printf "  %4.2f: %8.3f\n", $du,df_lookup(\@tpisort, $du);
    }
  }
  return;
}

#
# -- chktag: check existence and instruction match of tag --------------------
#

sub chktag {
  my ($tag,$inst) = @_;
  if (not exists $tags{$tag}) {
    printf STDERR "s370_perf_ana-E: tag %s not found\n", $tag;
    return 1;
  }
  my ($taginst) = ($tags{$tag}{txt} =~ m/([A-Z]+)/);
  if ($taginst ne $inst) {
    printf STDERR "s370_perf_ana-E: instruction mismatch for %s,".
                  " seen %s, expected %s\n", $tag,$taginst,$inst;
    return 1;
  }
  return 0;
}

#
# -- sprt: sprintf with sliding precision ------------------------------------
#

sub sprt {
  my ($val,$fmt) = @_;
  my ($ndig,$prec) = ($fmt =~ m/^%(\d+)\.(\d+)f$/);
  ## print "+++1 '$fmt': $ndig, $prec\n";
  my $str   = sprintf $fmt,$val;
  my $ntrim = length($str) - $ndig;
  if ($ntrim > 0) {
    if ($ntrim <= $prec+1) {
      $str = substr $str,0,$ndig;
    } else {
      $str = substr $str,0,length($str)-($prec+1);
    }
  }
  return $str;
}
